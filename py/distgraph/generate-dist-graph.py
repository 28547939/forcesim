import pandas
import matplotlib

from datetime import date

import matplotlib.pyplot as plt
import matplotlib.table as mpl_tbl
#import numpy as np

from typing import List
import argparse
import sys

import json

        
"""
Using the distribution computation function present in the forcesim code (via the v2-dist-points
client program), graph and describe the graph of the piecewise-linear distribution PDF
"""



"""

TODO
adjust height
grid lines on both axes
guide lines on y axis
annotation at current price, price view

"""


def render_from_points(xs, ys, meta, output_file):
    (segment_labels, ylabels, segment_values)=meta

    #fig=plt.figure(layout="constrained")
    fig=plt.figure()
    fig, (graph_ax, table_ax)=plt.subplots(2, 1)
    table_ax.axis('off')
    table_ax.axis('tight')
    #fig.set_constrained_layout(True)

    table_ax.xaxis.set_visible(False)
    table_ax.yaxis.set_visible(False)

    colors=['red', 'blue']

    segment_labels=[
        '$'+ s.replace(' ', '').replace('*', ' \cdot ') +'$'
        for s in segment_labels
    ]

    segment_labels.append('--')
    segment_values.append('--')


    def do_round(*args):
        def f(v): 
            return round(v, 5) if type(v) == float else v

        x= [
            (
                (
                    '(' + ', '.join(tuple(str(f(v)) for v in pt)) + ')' 
                    
                )
                if len(pt) > 1 else f(pt[0])
            )
            for pt in zip(*args)
        ]

        print(x)
        return x


    tbl=mpl_tbl.table(table_ax, 
        loc=mpl_tbl.Table.codes['upper center'],
        cellText=list(zip(do_round(xs, ys), segment_labels, do_round(segment_values))),
        rowLabels=range(0, len(xs)),
        colLabels=[ 
            'coordinates', 
            'next segment (${\Delta}x$) definition', 
            'next segment (${\Delta}x$) (value)' 
        ],
        fontsize=14
    )

    tbl.auto_set_font_size(False)
    for ((row, col), cell) in tbl.get_celld().items():
        if (col == 1 or col == 2):
            pass
            #cell.set_text_props(usetex=True)

    #graph_plt=fig.add_subplot()
    
    for i in range(0, len(xs)):
        graph_ax.plot(xs[i:i+2], ys[i:i+2], color=colors[i % 2])

        graph_ax.axvline(
            x=xs[i],
            linewidth=0.5,
            linestyle='--',
            color='black'
        )

    extent_1, extent_2 =graph_ax.get_xlim()
    collision_threshold = 0.01
    collision_level = 0

    # need second pass to have accurate x-limits
    for i in range(0, len(xs)):
        y_offset=5
        x_offset=-5

        if i != 0:
            print(f'extent: ({extent_1, extent_2}) xs: ({xs[i]}, {xs[i-1]})')

        if i != 0 and abs((xs[i] - xs[i-1])/(extent_2 - extent_1)) < collision_threshold:
            print(f'collision at {i}')
            collision_level += 1
            y_offset += collision_level*15
            x_offset += collision_level*2

        else:
            collision_level=0

        graph_ax.annotate(
            i, xy=(xs[i], 1),
            xycoords=("data", "axes fraction"),
            xytext=(x_offset, y_offset),
            textcoords='offset pixels',
        )

    #plt.subplots_adjust(wspace=0.5)
    # constrained layout doesn't work
    plt.tight_layout()



    print(segment_labels, segment_values)

    plt.ylabel('Density')
    plt.savefig(output_file)


def render_parameters_table(p, output_file):
    fig, table_ax = plt.subplots()

    table_ax.axis('off')
    table_ax.axis('tight')
    #fig.set_constrained_layout(True)

    table_ax.xaxis.set_visible(False)
    table_ax.yaxis.set_visible(False)

    tbl=mpl_tbl.table(table_ax, 
        loc=mpl_tbl.Table.codes['upper center'],
        cellText=list(p.items()),
        rowLabels=None,
        colLabels=[ 
            'parameter', 
            'value', 
        ],
        fontsize=14
    )

    plt.savefig(output_file)

def main():
    
    prs=argparse.ArgumentParser(
        prog='',
        description='produces graph of the points generated by the v2-dist-points program (via stdin)',
    )
    prs.add_argument('--distgraph-output-file', default='distgraph.png')
    prs.add_argument('--parameters-output-file', default='parameters.png')
    args=vars(prs.parse_args())
    (xs, ys, meta, parameters)=json.load(sys.stdin)

    # line to point
    #ax.stem( [ refdate ], [ ax.get_ylim() ] )

    print(meta)

    render_from_points(xs, ys, meta, args['distgraph_output_file'])
    render_parameters_table(parameters, args['parameters_output_file'])
    

if __name__ == '__main__':
    main()
